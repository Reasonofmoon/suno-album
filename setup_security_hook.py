import os
import stat

HOOK_CONTENT = r"""#!/bin/sh
# Pre-commit hook to block high-entropy strings and known key patterns
# Generated by Reason Moon Security Protocol

echo "üõ°Ô∏è  Running Security Scan..."

# 1. Check for Gemini/Google Keys
if grep -rE "AIza[0-9A-Za-z\\-_]{35}" .; then
    echo "‚ùå SECURITY BLOCK: Potential Google API Key detected."
    exit 1
fi

# 2. Check for OpenAI Keys (sk-...)
if grep -rE "sk-[a-zA-Z0-9]{48}" .; then
    echo "‚ùå SECURITY BLOCK: Potential OpenAI API Key detected."
    exit 1
fi

# 3. Check for Generic "API_KEY =" assignments (hardcoding) in Python
if grep -rE "API_KEY\s*=\s*['\"][a-zA-Z0-9\-_]{20,}['\"]" . --include=*.py; then
    echo "‚ùå SECURITY BLOCK: Hardcoded API_KEY detected in Python script."
    exit 1
fi

# 4. Check for .env files being committed (should be ignored, but double check)
if git diff --cached --name-only | grep -E "\.env$"; then
    echo "‚ùå SECURITY BLOCK: Attempting to commit a .env file."
    exit 1
fi

echo "‚úÖ Security Scan Passed."
exit 0
"""

def install_hook():
    hooks_dir = os.path.join(".git", "hooks")
    hook_path = os.path.join(hooks_dir, "pre-commit")
    
    if not os.path.exists(hooks_dir):
        print(f"‚ùå Error: .git/hooks directory not found. Is this a git repo?")
        return

    print(f"üõ°Ô∏è  Installing Security Hook to {hook_path}...")
    
    with open(hook_path, "w", encoding='utf-8') as f:
        f.write(HOOK_CONTENT)
    
    # Make executable (Windows doesn't use chmod +x exactly for git bash but good practice)
    # On Windows, Git Bash uses the shebang #!/bin/sh
    print("‚úÖ Hook installed. Any commit containing leaky patterns will now be BLOCKED.")

if __name__ == "__main__":
    install_hook()
